---
title: 数仓建模知识点
date: 2021-08-04 17:51:09
categories:
- 数仓建模
tags:
- 数仓
- 建模
---

# 维度建模和范式建模

## 范式建模

业务交易、服务于业务系统

- 范式：即关系模式。一张数据表的表结构，符合的设计标准的级别
- 目的在于降低数据的冗余性和保证数据的一致性。缺点是获取数据时，需要通过Join拼接出最后的数据。
- 范式建模将事物抽象为 实体（Entity）、属性、关系(Relationship)来表示数据关联和事物描述。

优点：准3NF、节约存储、易扩展、结构清晰、前期投入大，但后期成本低
缺点：周期长，见效慢、构建繁琐、查询复杂、学习成本高、对业务理解和建模能力都要求很高

需要梳理清楚企业各个业务系统的实体，实体间的关系，实体的属性，它的实施周期长，而互联网行业是不断探索，不断迭代的过程，当你还没有梳理清楚的时候，业务就已经发生了改变，甚至当你的数仓还没建好的时候，有可能这个企业已经黄了。所以就有了我接下来讲的维度建模。

## 维度建模  
分析、决策、服务于分析系统

维度建模是面向分析场景而生，针对分析场景构建数仓模型。它重点关注快速、灵活的解决分析需求，同时能够提供大规模数据的快速响应性能。不需要完整的梳理企业业务流程和数据，实施周期根据主题边界而定，容易快速实现，这也符合互联网行业的特点。

优点：方便使用、适合进行OLAP操作、建模方法简单、迭代式建设见效快
缺点：反范式、浪费存储、不易扩展、维度补全会造成存储的浪费，维度变化对数据的更新量大、前期成本低，后期会逐渐升高

# 次周复购率指标如何抽象通用的查询逻辑

分子是当前周的：复购客户数

分母是上周的：合作客户数

| 指标名     | 数仓字段 | 字段含义                           |
| ---------- | -------- | ---------------------------------- |
| 次日复购率 | rebuy_dt | 当天客户跟昨天有交集的复购客户     |
| 次周复购率 | rebuy_wk | 当天客户跟上周一周有交集的复购客户 |
| 次月复购率 | rebuy_mo | 当天客户跟上月一月有交集的复购客户 |

分子和分母的维度实际上是一样的，但是分母的时间维度的值需要是上个周期的时间；通过sql查询两个时间周期然后join在一起，在最外层进行指标计算，完全可以解决这个指标的计算问题；但是如果通过起源进行指标的计算，如何描述这个指标的计算逻辑？

## 如何知道某个客户是次周复购的

通过给客户打标的方式，这种方式不可行，原因：

- 表中存储的数据粒度是到sku的，在sku粒度给客户复购打标签，sku粒度的复购通过这个标签计算是没问题的
- 但是如果聚合到品类，通过sku的标签网上聚，复购数会减少很多，比如说看三级品类的复购，复购这个三级品类下的某个skuA肯定是复购，但是昨天买了这个三级品类下的skuB，今天买了这个三级品类下的skuA，仍然是这个三级品类的复购
- 如果按照上面给sku粒度打复购的标签，会导致品类的复购数量减少很多
- 正常应该先得到今天整个三级品类的购买客户id，再得到昨天整个三级品类的购买客户id，两个id求交集

```sql
SELECT  bitmap_count(bitmap_and(bitmap_union(customer_cnt),bitmap_union(customer_cnt)))  from app_bi_dashboard_cust_spu_sales_day_withpop  LIMIT 10
```

实现次周复购的思路：

1. 查询两次，因为分子和分母的时间维度不同，分子查询本周复购客户数，分母查询上周合作客户数；这种查询方案实现起来还好，但是起源不支持一个指标通过查询两次进行计算。
2. 冗余一列，叫上周同日合作客户id，因为数仓给的是天粒度的数据，所以每天的数据，在当天的合作客户id(customer_id)的基础上，冗余一列，上周同日的合作客户id(last_wk_customer_id)，这样计算周的复购的时候，只需要查询一次：`bitmap_count(bitmap_and(bitmap_union(customer_id),bitmap_union(last_wk_customer_id)))/bitmap_count(last_wk_customer_id) where wk=?`
3. 将复购指标通过单独的表提供，单独的表提供起来，可以不通过增加列的方式提供，增加一个叫做复购类型的字段，来表示当前购买的客户是哪天的，不同时间周期的指标，公式可以是一个，只要添加不同的type值就行了：``bitmap_count(bitmap_and(bitmap_union(customer_id),bitmap_union(last_customer_id)))/bitmap_count(last_customer_id) where wk=? and type='last_wk' `

# 新增sku的不同周期的计算方式

基于数仓提供的是dt粒度的数据的场景

# 参考链接

- [我对维度建模和范式建模的一点理解](https://blog.csdn.net/hsl971105/article/details/108165215)
