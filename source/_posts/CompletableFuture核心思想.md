---
title: CompletableFuture核心思想
date: 2019-10-16 21:10:13
tags:
- java
- completablefuture
- 多线程
- 异步
categories:
- java
---

# 介绍

首先阻塞和非阻塞是针对于异步事件的，单线程执行谈不上阻塞和非阻塞。启动一个线程去执行一个逻辑，该线程就是一个异步事件，获取该线程的结果的过程就涉及到阻塞和非阻塞两种方式。

- 如果你等着拿到了该线程的结果才去进行下一步，那么就是阻塞的
- 将所有要执行的代码通过future通通提交给java虚拟机，然后进行后续的逻辑，什么时候那个线程的结果算出来了，java虚拟机自会做真实的运算，这种就是非阻塞的

<mark>Java 8 CompletableFuture 类将事件合成和组合到一种执行计划中，这个计划可以使用代码来轻松而又简洁地表示。我们可以直接提交该执行计划，执行计划需要的数据什么时候来了什么时候计算，而不需要阻塞等待过程中每一个需要的结果，直到所有都计算完才能进行后续的代码。</mark>

# 为什么要使用CompletableFuture

最主要的一个作用是为线程添加一个处理器，当线程执行完成之后，拿到线程处理之后的结果，进行后续的处理。

对于单线程来说，该作用不大，为什么呢，因为添加处理器来监听结果，再去进一步处理结果，跟把这部分处理逻辑写在当前线程的run方法中是等效的。

## 但是多线程就不一样了

多线程模型中一个重要的问题是：怎么能知道所有的线程都执行完了，因为只有知道都执行完了才能进行后续的处理逻辑。

在有CompletableFuture之前，要想拿到所有线程的处理结果，要么轮询去检查线程是否执行完了，要么通过Future的get方法阻塞式的等待所有的线程执行完去做进一步的处理。

# 代码层面

CompletableFuture提供了很多的方法可以针对多线程的结果之间的协调，这使多线程的处理逻辑更加灵活。

## CompletionStage

CompletableFuture实现了该接口，该接口的意思是完成的各个阶段，其中封装了在各个阶段需要触发的动作。一个阶段的计算完成之后，可能触发另一个阶段的动作。该类为我们封装了各个异步操作之间的协调方式。我们不用在通过阻塞或者轮询的方式去获取各个异步操作执行的状态，该类直接会在到达某个阶段之后帮我们触发相关的处理器。

## 实现异常捕获

线程内部的异常会被限制在线程范围内，如果不通过手动捕获，该异常无法抛出。

---

### 参考

- [阻塞还是不阻塞？](https://www.ibm.com/developerworks/cn/java/j-jvmc3/index.html)
